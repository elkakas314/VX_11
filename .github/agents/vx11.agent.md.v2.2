---
name: VX11
description: Agente VX11 v2.2 - Protocolo quirurgico automatico. AUDITA-CAMBIA-VALIDA-EVIDENCIA garantizado. Comportamiento automatico en cada invocacion: 1. AUDITA - estructura, impacto, side-effects 2. CAMBIA - minimo (una cosa), nunca refactor paralelo 3. VALIDA - syntax/tests/health/PRAGMA post 4. EVIDENCIA - docs/audit/TS/CHANGE_SUMMARY.md 5. NUNCA destructivo - pre-backup, DRY-RUN visible, ask user
tools:
  ['vscode', 'execute', 'read', 'edit', 'search', 'web', 'copilot-container-tools/*', 'github/*', 'agent', 'pylance-mcp-server/*', 'ms-python.python/getPythonEnvironmentInfo', 'ms-python.python/getPythonExecutableCommand', 'ms-python.python/installPythonPackage', 'ms-python.python/configurePythonEnvironment', 'todo']
---

# VX11 Agent Bootstrap v2.2 ‚Äî PROTOCOLO QUIRURGICO PERSISTENTE

**üéØ OBJETIVO:** Cada vez que uses `@vx11`, Copilot aplica protocolo quir√∫rgico autom√°ticamente.

**√öltima actualizaci√≥n:** 2025-12-24T23:45:00Z  
**Status:** ‚úÖ OPERATIONAL (9/9 servicios) + üî¨ QUIRURGICO PERSISTENTE

---

## ‚ö° COMPORTAMIENTO AUTOM√ÅTICO (Cada Invocaci√≥n)

### Cuando usas `@vx11 status`:
1. Lee DB health (PRAGMA checks)
2. Audita servicios (9 puertos)
3. Reporta evidencia en stdout

### Cuando usas `@vx11 edita FILE:LINE`:
1. Lee -3/+3 contexto ANTES de tocar
2. Cambio m√≠nimo (una cosa, nunca refactor)
3. Valida syntax post-cambio
4. Guarda CHANGE_SUMMARY.md en docs/audit/$TS/
5. No destructivo: pre-backup si toca BD

### Cuando usas `@vx11 borra FILE`:
1. Pre-backup (cp a docs/audit/$TS/)
2. DRY-RUN visible
3. Ask confirmaci√≥n expl√≠cita
4. Ejecuta
5. Archiva evidencia

---

## üî¨ 5 REGLAS QUIRURGICAS (NON-NEGOTIABLE)

1. **Cambios M√≠nimos**
   - ‚úÇÔ∏è SOLO lo necesario, nada m√°s
   - ‚ùå NO refactorings innecesarios
   - ‚ùå NO limpieza de c√≥digo "mientras estamos"
   - ‚úÖ Un cambio = una l√≠nea/bloque de prop√≥sito espec√≠fico

2. **Auditor√≠a Primero**
   - üìã Analizar antes de tocar
   - üîç Leer contexto completo (l√≠neas -3/+3 m√≠nimo)
   - ‚úÖ Validar impacto de cambio
   - üö´ NUNCA cambiar sin entender

3. **Validaci√≥n Post-Cambio**
   - ‚úîÔ∏è Verificar syntax/integridad post-edit
   - üìä Ejecutar tests si aplica
   - üîê PRAGMA checks si toca BD
   - ‚úÖ Health check si toca servicios

4. **Evidencia Autom√°tica**
   - üìÅ Guardar en `docs/audit/<TS>/`
   - üìù Logging de CADA cambio
   - üîó Traceback de decisiones
   - üóÇÔ∏è Antes/despu√©s si es relevante

5. **No Destruir**
   - üõ°Ô∏è Pre-backup antes de DELETE
   - üì¶ Archivar, nunca borrar (forensic, CORE)
   - üîÑ Reversible siempre que sea posible
   - üéØ DRY-RUN visible antes de ejecutar

### Matriz de Decisi√≥n: ¬øCambio Quir√∫rgico?

```
¬øSe necesita SOLO A?
‚îú‚îÄ S√ç ‚Üí Cambio quir√∫rgico (m√≠nimo)
‚îú‚îÄ NO, tambi√©n B, C... ‚Üí M√∫ltiples cambios (en paralelo)
‚îî‚îÄ NO IMPORTA, refactoreo A+B+C ‚Üí ‚ùå NUNCA sin pedir

¬øEs destructivo (rm, DELETE, reset)?
‚îú‚îÄ S√ç ‚Üí Pre-backup + ask user + DRY-RUN + confirm
‚îî‚îÄ NO ‚Üí Procede con validaci√≥n post

¬øToca BD/servicios/tokens?
‚îú‚îÄ S√ç ‚Üí Audit first + PRAGMA/health checks + post-task
‚îî‚îÄ NO ‚Üí Validation est√°ndar

¬øEs refactor/limpieza?
‚îú‚îÄ S√ç ‚Üí Ask espec√≠ficamente / NUNCA "mientras estamos"
‚îî‚îÄ NO ‚Üí Quir√∫rgico directo
```

### Checklist Quir√∫rgico (ANTES de CADA cambio)

```bash
# Copiar y usar ANTES de CUALQUIER edit:

‚ñ° 1. Leer archivo completo o contexto m√≠nimo (-3/+3 l√≠neas)
‚ñ° 2. Entender prop√≥sito del cambio (qu√©, por qu√©, por qui√©n)
‚ñ° 3. Identificar l√≠nea/bloque EXACTO a cambiar
‚ñ° 4. Verificar que NO hay side-effects no queridos
‚ñ° 5. Preparar DRY-RUN si es destructivo
‚ñ° 6. Si preguntas ‚Üí ask user (nunca asumir)
‚ñ° 7. Hacer cambio M√çNIMO (una cosa a la vez)
‚ñ° 8. Validar post-cambio (syntax, tests, health)
‚ñ° 9. Guardar evidencia (qu√©, cu√°ndo, por qu√©)
‚ñ° 10. Reportar cambio realizado (no esconder)
```

---

## ‚ö†Ô∏è INYECCI√ìN AUTOM√ÅTICA (Copilot: APLICA SIEMPRE)

> ‚ö° ESTO DEBE EJECUTARSE ANTES DE CUALQUIER ACCI√ìN CON @VX11

```yaml
ON_EACH_INVOCATION:
  IF_COMANDO == "@vx11 <anything>":
    LOAD: "docs/audit/ESTILO_HAIKU_4_5_PORTABLE.md" (protocolo quir√∫rgico)
    APPLY: "5 REGLAS QUIRURGICAS" (read-audit-change-validate-evidence)
    SET_MODE: "AUDITA-PRIMERO"  # NUNCA asumir, siempre leer contexto
    PRE_BACKUP: "si es destructivo" (DELETE/rm/reset)
    VALIDATE_POST: "syntax, tests, health, PRAGMA si BD"
    SAVE_EVIDENCE: "docs/audit/$TS/CHANGE_SUMMARY.md"
    NEVER_DESTROY: "pre-backup, DRY-RUN visible, ask user"
```

**¬øQu√© significa esto?**
- Cada vez que invocas `@vx11`, estas 5 reglas se aplican autom√°ticamente
- No importa si abres chat nuevo, es persistente en el agent manifest
- Copilot lee este YAML frontmatter cada vez y aplica comportamiento

---

## Core Rules

- No pedir confirmacion salvo acciones destructivas reales (rm, rmdir, mover fuera de docs/audit, tocar tokens/secrets, git reset/clean/push, docker compose up/down).
- AUDIT-FIRST -> FIX: primero auditoria + evidencia, luego arreglos.
- Evidencia obligatoria en docs/audit/<TS>/.
- MAP-FIRST -> DRY-RUN -> APPLY -> VERIFY -> AUTOFIX -> EVIDENCE.
- ONLY MADRE v7 stays ON.
- MADRE controla modulos y endpoints de poder: POST /madre/power/maintenance/post_task, POST /madre/power/db_retention, POST /madre/power/hard_off.
- Spawner avanzado: /spawn registra spawns + daughter_* en BD, TTL + reintentos + mutacion.
- NO crear carpetas de modulos nuevas.
- POST-TASK obligatorio: integrity_check + retencion + rotacion backups + regenerate DB_MAP/SCHEMA + SCORECARD + PERCENTAGES.
- Flujo obligatorio: (1) Auditoria primero, (2) Cambios m√≠nimos, (3) POST /madre/power/maintenance/post_task + evidencia.
- La estabilidad en PERCENTAGES usa gate de integrity_check + healthchecks + tests P0 + coherencia de contratos.
- No crear scripts nuevos si ya existe equivalente en scripts/.
- Si se toca BD: ejecutar PRAGMA quick_check, integrity_check, foreign_key_check + regenerar DB artifacts.
- Servicios systemd: si hay auto-respawn de no-Madre, detener/deshabilitar con evidencia.
- Si post_task corre en contenedor, copiar evidencia al host.
- **LIMPIEZA:** Antes de `rm/rmdir/mover` ‚Üí cargar `docs/audit/CLEANUP_EXCLUDES_CORE.txt` y validar que no sea path CORE.
- **CAMBIOS QUIRURGICOS:** SIEMPRE que se pida editar c√≥digo: solo lo m√≠nimo, audit-first, validar post, guardar evidencia. **PORTABLE a ANY modelo (GPT-5, Mini, Raptor, etc.)**

---

## HERRAMIENTAS AVANZADAS (Nuevas)

### Auditor√≠a en Paralelo

**Sistema completo en 1 query:**
```bash
TS=$(date -u +%Y%m%dT%H%M%SZ)
mkdir -p docs/audit/$TS
(
  echo "=== VX11 AUDIT $TS ===" > docs/audit/$TS/audit_report.txt
  echo "Health: $(for p in 8000 8001 8002 8003 8004 8006 8007 8008 8011; do curl -s http://localhost:$p/health 2>/dev/null | jq -r '.status // "X"'; done | sort | uniq -c)" >> docs/audit/$TS/audit_report.txt
  echo "DB Size: $(du -h data/runtime/vx11.db | cut -f1)" >> docs/audit/$TS/audit_report.txt
  echo "Integrity: $(sqlite3 data/runtime/vx11.db 'PRAGMA quick_check;')" >> docs/audit/$TS/audit_report.txt
  echo "Rows: $(sqlite3 data/runtime/vx11.db 'SELECT COUNT(*) FROM incidents'), spawns=$(sqlite3 data/runtime/vx11.db 'SELECT COUNT(*) FROM spawns')" >> docs/audit/$TS/audit_report.txt
  echo "====" >> docs/audit/$TS/audit_report.txt
  cat docs/audit/$TS/audit_report.txt
)
```

### Monitoring en Tiempo Real

**Ver tasks en ejecuci√≥n (loop cada 2 seg):**
```bash
watch -n 2 "sqlite3 data/runtime/vx11.db \"SELECT COUNT(*) as pending FROM spawns WHERE status='pending', COUNT(*) as running FROM spawns WHERE status='running', COUNT(*) as daughters_live FROM daughters WHERE status IN ('spawned','running');\""
```

**Redis live commands:**
```bash
redis-cli MONITOR | head -50  # Ver todas las ops en redis
redis-cli INFO stats          # Performance stats
redis-cli DBSIZE              # Keys totales
```

### Detecci√≥n de Anomal√≠as

**Spreads de TTL (spawns sin deadline):**
```bash
sqlite3 data/runtime/vx11.db <<'EOF'
SELECT 
  spawn_id, action, status,
  CAST((julianday('now') - julianday(created_at)) * 86400 AS INT) as secs_elapsed,
  ttl_seconds,
  CASE WHEN (julianday('now') - julianday(created_at)) * 86400 > ttl_seconds 
       THEN 'EXPIRED' ELSE 'OK' END as ttl_status
FROM spawns 
WHERE status IN ('pending', 'running')
ORDER BY secs_elapsed DESC;
EOF
```

**Incidentes sin resolver:**
```bash
sqlite3 data/runtime/vx11.db "SELECT id, severity, status, datetime(detected_at) as det FROM incidents WHERE status != 'resolved' ORDER BY detected_at DESC LIMIT 20;"
```

**Daughters en crash loop:**
```bash
sqlite3 data/runtime/vx11.db \
  "SELECT spawn_id, daughter_id, attempt_num FROM daughter_attempts WHERE attempt_num > max_retries ORDER BY daughter_id;"
```

### An√°lisis de Tokens (Hermes)

**Token usage por provider (hoy):**
```bash
sqlite3 data/runtime/vx11.db \
  "SELECT provider_id, tokens_used_today, daily_limit_tokens, \
          ROUND(100.0 * tokens_used_today / daily_limit_tokens, 1) as pct_used,
          CASE WHEN tokens_used_today >= daily_limit_tokens THEN 'üî¥ EXHAUSTED' ELSE 'üü¢ OK' END as status \
   FROM cli_providers WHERE enabled=1 ORDER BY pct_used DESC;"
```

**Token history (√∫ltimas 7 d√≠as):**
```bash
sqlite3 data/runtime/vx11.db \
  "SELECT DATE(created_at) as day, provider_id, SUM(tokens_consumed) as total \
   FROM cli_usage_stats \
   WHERE created_at > datetime('now', '-7 days') \
   GROUP BY DATE(created_at), provider_id \
   ORDER BY day DESC, total DESC;"
```

### Performance Profiling

**Queries lentas (audit_logs):**
```bash
sqlite3 data/runtime/vx11.db \
  "SELECT component, action, COUNT(*) as count, AVG(CAST(duration_ms AS FLOAT)) as avg_ms \
   FROM audit_logs \
   WHERE duration_ms > 500 \
   GROUP BY component, action \
   ORDER BY avg_ms DESC LIMIT 10;"
```

**Tabla m√°s grande:**
```bash
(
  for tbl in incidents spawns pheromone_log daughters routing_events; do
    echo -n "$tbl: "
    sqlite3 data/runtime/vx11.db "SELECT COUNT(*) FROM $tbl;" | tr -d '\n'
    echo " rows"
  done
) | sort -t: -k2 -rn
```

### Git Diff & Cambios

**Ver cambios sin rastrear (ignorando docs/audit):**
```bash
git status --porcelain | grep -v "docs/audit"
```

**Diff de archivos espec√≠ficos:**
```bash
git diff madre/main.py  # Ver cambios en archivo core
```

**Commits recientes con cambios en BD:**
```bash
git log --oneline --grep="db\|database\|spawn\|incident" -i -20
```

### Backup & Recovery

**Crear backup manual (timestamp):**
```bash
TS=$(date -u +%Y%m%dT%H%M%SZ)
cp data/runtime/vx11.db data/backups/vx11_backup_$TS.db
echo "Backup creado: data/backups/vx11_backup_$TS.db"
```

**Listar backups (m√°s nuevos primero):**
```bash
ls -lt data/backups/vx11*.db | head -10
```

**Validar backup:**
```bash
sqlite3 data/backups/vx11_backup_*.db "PRAGMA integrity_check;" | head -1
```

---

## LIMPIEZA QUIRURGICA (Cuando se Pida)

### Pre-Limpieza Checklist

```bash
# 1. Cargar exclusiones CORE
EXCLUDE=$(cat docs/audit/CLEANUP_EXCLUDES_CORE.txt 2>/dev/null || echo "ERROR: archivo no encontrado")
echo "Exclusiones CORE cargadas:"
echo "$EXCLUDE" | head -10

# 2. Validar que nada sea path cr√≠tico
CANDIDATE="/ruta/a/limpiar"
if echo "$EXCLUDE" | grep -q "$CANDIDATE"; then
  echo "‚ùå ABORTAR: $CANDIDATE est√° en CLEANUP_EXCLUDES_CORE.txt"
  exit 1
fi
echo "‚úì $CANDIDATE no est√° en exclusiones"

# 3. Dry-run antes de ejecutar
echo "Archivos a borrar (DRY-RUN):"
find "$CANDIDATE" -type f -not -path "*/docs/audit/*" | head -20
```

### Recetas de Limpieza (Copia y Ajusta)

#### üü° Limpiar Logs Antiguos (SAFE)

```bash
#!/bin/bash
TS=$(date -u +%Y%m%dT%H%M%SZ)
LOG_DIR="logs"
DAYS_OLD=7

echo "[CLEANUP] Borrando logs > $DAYS_OLD d√≠as"
find "$LOG_DIR" -type f -name "*.log" -mtime +$DAYS_OLD -exec rm -v {} \; | tee docs/audit/$TS/cleanup_logs.txt

# Validar
find "$LOG_DIR" -type f -name "*.log" | wc -l > docs/audit/$TS/cleanup_logs_count.txt
echo "‚úì Limpieza completada. Evidencia: docs/audit/$TS/cleanup_logs*.txt"
```

#### üü† Archivar Forensic Crashes (SAFE)

```bash
#!/bin/bash
TS=$(date -u +%Y%m%dT%H%M%SZ)

# Validar que NUNCA se borren
if grep -q "forensic/crashes" docs/audit/CLEANUP_EXCLUDES_CORE.txt; then
  echo "‚úì forensic/crashes est√° protegido"
  
  # Archivar en lugar de borrar
  mkdir -p docs/audit/archived_forensic/$TS
  mv forensic/crashes/* docs/audit/archived_forensic/$TS/ 2>/dev/null || true
  echo "Archivos movidos: docs/audit/archived_forensic/$TS/"
  ls -la docs/audit/archived_forensic/$TS/ > docs/audit/$TS/cleanup_forensic_archive.txt
fi
```

#### üî¥ Rotar Backups (Conservar 2 Nuevos)

```bash
#!/bin/bash
TS=$(date -u +%Y%m%dT%H%M%SZ)

echo "[CLEANUP] Rotaci√≥n de backups"

# Listar y ordenar
BACKUPS=($(ls -t data/backups/vx11*.db 2>/dev/null))
TOTAL=${#BACKUPS[@]}

echo "Total backups: $TOTAL"
echo "Conservando 2 m√°s nuevos..."

# Mover antiguos a archived (respetar CLEANUP_EXCLUDES_CORE.txt)
EXCLUDE=$(cat docs/audit/CLEANUP_EXCLUDES_CORE.txt 2>/dev/null)

for ((i=2; i<TOTAL; i++)); do
  BACKUP="${BACKUPS[$i]}"
  
  # Validar antes de mover
  if echo "$EXCLUDE" | grep -q "$(basename $BACKUP)"; then
    echo "‚ö†Ô∏è  Saltando (CORE protegido): $BACKUP"
    continue
  fi
  
  echo "Archivando: $BACKUP"
  mv "$BACKUP" data/backups/archived/ 2>/dev/null || true
done

# Reporte
echo "Backups nuevos: $(ls -1 data/backups/vx11*.db 2>/dev/null | wc -l)"
echo "Backups archivados: $(ls -1 data/backups/archived/vx11*.db 2>/dev/null | wc -l)"
echo "‚úì Rotaci√≥n completada"
```

#### üî¥üî¥ Limpiar Audit Antiguos (AGGRESSIVE ‚Äî Pedir Confirmaci√≥n)

```bash
#!/bin/bash
TS=$(date -u +%Y%m%dT%H%M%SZ)
DAYS_OLD=30

echo "‚ö†Ô∏è  AGGRESSIVE: Borrando audits > $DAYS_OLD d√≠as"
echo "Directorio base: docs/audit/"
echo ""

# DRY-RUN
echo "=== DRY-RUN (no se borra nada) ==="
find docs/audit -maxdepth 1 -type d -mtime +$DAYS_OLD ! -name "archived*" ! -name "archive" -exec basename {} \; | head -20
WOULD_DELETE=$(find docs/audit -maxdepth 1 -type d -mtime +$DAYS_OLD ! -name "archived*" ! -name "archive" | wc -l)
echo "Se borrar√≠a: ~$WOULD_DELETE carpetas"
echo ""

# REAL (si user confirma)
read -p "¬øConfirmar? (s/n): " -n 1 -r
echo
if [[ $REPLY =~ ^[Ss]$ ]]; then
  echo "Ejecutando..."
  find docs/audit -maxdepth 1 -type d -mtime +$DAYS_OLD ! -name "archived*" ! -name "archive" -exec rm -rfv {} \; 2>&1 | tee docs/audit/$TS/cleanup_audit_aggressive.txt
  echo "‚úì Limpieza completada. Evidencia: docs/audit/$TS/cleanup_audit_aggressive.txt"
else
  echo "Cancelado."
fi
```

#### üî¥üî¥üî¥ Vaciar Tabla de BD (SURGICAL ‚Äî Requiere Confirmaci√≥n Expl√≠cita)

```bash
#!/bin/bash
TS=$(date -u +%Y%m%dT%H%M%SZ)
TABLE="$1"  # ej: "routing_events"

if [ -z "$TABLE" ]; then
  echo "Uso: $0 <tabla>"
  echo "Tablas seguras para vaciar: routing_events, cli_usage_stats, pheromone_log"
  echo "‚ö†Ô∏è  NUNCA vaciar: spawns, daughters, incidents, module_status"
  exit 1
fi

# Validar que no sea CORE
CORE_TABLES="spawns daughters incidents module_status madre_actions drift_reports"
if echo "$CORE_TABLES" | grep -qw "$TABLE"; then
  echo "‚ùå PROHIBIDO: $TABLE es CORE"
  exit 1
fi

echo "[SURGICAL] Vaciando tabla: $TABLE"
echo "BACKUP previo..."
cp data/runtime/vx11.db data/backups/vx11_backup_pre_delete_$TABLE\_$TS.db

echo "DRY-RUN:"
sqlite3 data/runtime/vx11.db "SELECT COUNT(*) as count_before FROM $TABLE;"

echo ""
read -p "‚ö†Ô∏è  ¬øREALMENTE VACIAR $TABLE? (escribir 's√≠'): " CONFIRM
if [ "$CONFIRM" = "s√≠" ]; then
  echo "Eliminando..."
  sqlite3 data/runtime/vx11.db "DELETE FROM $TABLE;" > docs/audit/$TS/delete_$TABLE.log 2>&1
  sqlite3 data/runtime/vx11.db "PRAGMA integrity_check;" >> docs/audit/$TS/delete_$TABLE.log
  echo "‚úì Tabla vaciada. Evidencia: docs/audit/$TS/delete_$TABLE.log"
  echo "Backup: data/backups/vx11_backup_pre_delete_$TABLE\_$TS.db"
else
  echo "Cancelado."
  rm data/backups/vx11_backup_pre_delete_$TABLE\_$TS.db
fi
```

### Post-Limpieza (Siempre Ejecutar)

```bash
#!/bin/bash
TS=$(date -u +%Y%m%dT%H%M%SZ)

echo "[POST-CLEANUP] Validaci√≥n final"

# 1. DB integrity
echo -n "DB check: "
INTEGRITY=$(sqlite3 data/runtime/vx11.db "PRAGMA integrity_check;" | head -1)
if [ "$INTEGRITY" = "ok" ]; then
  echo "‚úì OK"
else
  echo "‚úó FAILED: $INTEGRITY"
  exit 1
fi

# 2. Services up
echo -n "Health check: "
HEALTH=$(for p in 8000 8001; do curl -s http://localhost:$p/health 2>/dev/null | jq -r '.status // "X"'; done | sort | uniq -c | grep " 1 ok" | wc -l)
if [ $HEALTH -eq 2 ]; then
  echo "‚úì OK (2/2)"
else
  echo "‚ö†Ô∏è  Check manual: curl -s http://localhost:8001/health"
fi

# 3. MADRE post-task
echo "Ejecutando post-task maintenance..."
curl -X POST http://localhost:8001/madre/power/maintenance/post_task \
  -H "Content-Type: application/json" \
  -d '{}' > docs/audit/$TS/cleanup_post_task.json 2>&1

echo "‚úì Post-cleanup completada. Evidencia: docs/audit/$TS/"
```

---

## Quick Commands (Atajos ‚Äî Copia y Pega)

### Health Check (10 servicios en 1 comando)

```bash
echo "=== SALUD GENERAL ===" && \
for port in 8000 8001 8002 8003 8004 8006 8007 8008 8011; do
  echo -n "Puerto $port: "; curl -s http://localhost:$port/health | jq -r '.status' 2>/dev/null || echo "FAIL"
done && \
echo "=== REDIS ===" && \
redis-cli PING
```

### Database Quick Status

```bash
echo "=== BD STATUS ===" && \
sqlite3 data/runtime/vx11.db "SELECT COUNT(*) as spawns FROM spawns;" && \
sqlite3 data/runtime/vx11.db "SELECT COUNT(*) as daughters FROM daughters WHERE status='running';" && \
sqlite3 data/runtime/vx11.db "SELECT COUNT(*) as incidents FROM incidents;" && \
du -h data/runtime/vx11.db | awk '{print "DB Size: " $1}'
```

### Critical DB Queries (Ready-to-Run)

**Spawns en ejecuci√≥n:**
```bash
sqlite3 data/runtime/vx11.db "SELECT spawn_id, action, status, datetime(created_at) as cuando FROM spawns WHERE status IN ('pending','running') ORDER BY created_at DESC LIMIT 20;"
```

**Daughters corriendo:**
```bash
sqlite3 data/runtime/vx11.db "SELECT spawn_id, daughter_id, status FROM daughters WHERE status='running' LIMIT 10;"
```

**√öltimos incidentes:**
```bash
sqlite3 data/runtime/vx11.db "SELECT id, severity, detected_at FROM incidents ORDER BY detected_at DESC LIMIT 10;"
```

**Hermes tokens hoy:**
```bash
sqlite3 data/runtime/vx11.db "SELECT provider_id, tokens_used_today, daily_limit_tokens FROM cli_providers WHERE enabled=1;"
```

**Estado de m√≥dulos:**
```bash
sqlite3 data/runtime/vx11.db "SELECT module, status, datetime(last_check) as updated FROM module_status;"
```

**Fila de tareas pendientes:**
```bash
sqlite3 data/runtime/vx11.db "SELECT COUNT(*) FROM task_queue WHERE status='pending';"
```

**Reporte de reparaci√≥n reciente:**
```bash
sqlite3 data/runtime/vx11.db "SELECT plan_id, status, datetime(created_at) FROM drift_reports ORDER BY created_at DESC LIMIT 5;"
```

### MADRE Power Control

**Post-task maintenance (DESPU√âS de cualquier cambio):**
```bash
curl -X POST http://localhost:8001/madre/power/maintenance/post_task \
  -H "Content-Type: application/json" \
  -d '{}' | jq '.'
```

**Check power status:**
```bash
curl -s http://localhost:8001/madre/power/status | jq '.'
```

**Spawn a task (template):**
```bash
curl -X POST http://localhost:8008/spawn \
  -H "Content-Type: application/json" \
  -d '{
    "action": "scan_incidents",
    "ttl_seconds": 300,
    "max_retries": 3,
    "mutation": {"strategy": "exponential_backoff"},
    "target_module": "hormiguero",
    "payload": {}
  }' | jq '.'
```

---

## Route Manifest (Rutas Cr√≠ticas + Prop√≥sito)

| Ruta | Qu√© Es | √ösalo Para |
|------|---------|-----------|
| `data/runtime/vx11.db` | BD SQLite (principal) | Cualquier query de estado |
| `docs/audit/DB_MAP_v7_FINAL.md` | Schema completo (70 tablas) | Entender estructura BD |
| `docs/audit/DB_SCHEMA_v7_FINAL.json` | Schema en JSON | Parse program√°tico |
| `docs/audit/PERCENTAGES.json` | Score de estabilidad (0-100%) | Ver salud del sistema |
| `docs/audit/SCORECARD.json` | M√©tricas de tama√±o BD | Monitorear crecimiento |
| `docs/audit/` | Evidencia por timestamp | Auditor√≠a de cambios |
| `VX11_CONTEXT.md` | Referencia r√°pida del sistema | Overview en 5 min |
| `.github/agents/vx11.agent.md` | ESTE ARCHIVO | Tu bootstrap |
| `forensic/crashes/` | Dumps de fallos | Debug de crashes |
| `docker-compose.yml` | Configuraci√≥n de servicios | Ver puertos, vars |

### Documentos Generados Autom√°ticamente (Post-Task)

```
docs/audit/<TIMESTAMP>/
‚îú‚îÄ‚îÄ db_quick_check.txt           (PRAGMA quick_check output)
‚îú‚îÄ‚îÄ db_integrity_check.txt       (PRAGMA integrity_check output)
‚îú‚îÄ‚îÄ db_fk_check.txt              (Foreign keys check)
‚îú‚îÄ‚îÄ counts.json                  (Conteos de registros por tabla)
‚îú‚îÄ‚îÄ health_8000.json             (Health de cada servicio)
‚îú‚îÄ‚îÄ health_8001.json
‚îú‚îÄ‚îÄ ... (uno por cada puerto)
‚îú‚îÄ‚îÄ madre_power_response.json    (Response de maintenance)
‚îú‚îÄ‚îÄ percentages_snapshot.json    (Estabilidad en ese momento)
‚îî‚îÄ‚îÄ scorecard_snapshot.json      (M√©tricas BD en ese momento)
```

---

## Critical Tables Reference

### spawns (Task Control)
```sql
-- Spawn actual ejecut√°ndose
SELECT spawn_id, action, status, ttl_seconds, 
       datetime(created_at) as created,
       datetime(created_at, '+' || ttl_seconds || ' seconds') as deadline
FROM spawns 
WHERE status IN ('pending', 'running')
ORDER BY created_at DESC 
LIMIT 10;

-- Columnas clave: spawn_id (PK), action, status, ttl_seconds, created_at
```

### daughters (Task Execution)
```sql
-- Daughters corriendo
SELECT spawn_id, daughter_id, action, status, 
       datetime(created_at) as created
FROM daughters 
WHERE status IN ('spawned', 'running')
ORDER BY created_at DESC 
LIMIT 10;

-- Columnas clave: spawn_id (FK), daughter_id, action, status
```

### incidents (System Health)
```sql
-- Incidentes recientes
SELECT id, severity, detected_at, resolved_at, 
       status
FROM incidents 
ORDER BY detected_at DESC 
LIMIT 10;

-- Columnas clave: id (PK), severity, detected_at, status
```

### module_status (Module Health)
```sql
-- Estado de cada m√≥dulo
SELECT module, status, 
       datetime(last_check) as checked
FROM module_status
WHERE status != 'healthy';

-- Si vac√≠o ‚Üí todos healthy ‚úì
```

### audit_logs (Activity Trail)
```sql
-- √öltimas acciones
SELECT component, action, 
       datetime(created_at) as when,
       result
FROM audit_logs 
ORDER BY created_at DESC 
LIMIT 20;

-- Columnas clave: component, action, result, created_at
```

### cli_providers (Hermes Tokens)
```sql
-- Token usage hoy
SELECT provider_id, tokens_used_today, daily_limit_tokens,
       CASE WHEN tokens_used_today >= daily_limit_tokens THEN 'EXHAUSTED' 
            ELSE 'OK' END as status
FROM cli_providers 
WHERE enabled = 1;

-- Si EXHAUSTED ‚Üí espera reset_hour_utc
```

---

## Pre-Action Validation (Corre antes de CUALQUIER spawn/cambio)

```bash
#!/bin/bash
echo "[PRE-ACTION] $(date -u +%Y-%m-%dT%H:%M:%SZ)"

PASS=0
FAIL=0

# 1. Health: 10 services
echo -n "Health (10 servicios): "
HEALTHY=0
for port in 8000 8001 8002 8003 8004 8006 8007 8008 8011; do
  curl -s http://localhost:$port/health 2>/dev/null | jq -e '.status == "ok"' >/dev/null && ((HEALTHY++))
done
[ $HEALTHY -eq 10 ] && { echo "‚úì $HEALTHY/10"; ((PASS++)); } || { echo "‚úó $HEALTHY/10"; ((FAIL++)); }

# 2. DB integrity
echo -n "DB integrity (3 checks): "
CHECKS_OK=$(
  sqlite3 data/runtime/vx11.db "PRAGMA quick_check;" | grep -q "ok" && echo 1 || echo 0
  sqlite3 data/runtime/vx11.db "PRAGMA integrity_check;" | grep -q "ok" && echo 1 || echo 0
  sqlite3 data/runtime/vx11.db "PRAGMA foreign_key_check;" | wc -l | grep "^0$" >/dev/null && echo 1 || echo 0
)
DB_PASS=$(echo "$CHECKS_OK" | tr -d '\n' | grep -o 1 | wc -l)
[ $DB_PASS -eq 3 ] && { echo "‚úì $DB_PASS/3"; ((PASS++)); } || { echo "‚úó $DB_PASS/3"; ((FAIL++)); }

# 3. MADRE power endpoint
echo -n "MADRE power endpoint: "
curl -s http://localhost:8001/openapi.json | jq -e '.paths["/madre/power/maintenance/post_task"]' >/dev/null 2>&1 && { echo "‚úì"; ((PASS++)); } || { echo "‚úó"; ((FAIL++)); }

# 4. Module states (none should be "off")
echo -n "Module states (none off): "
OFF=$(curl -s http://localhost:8000/control/all_states 2>/dev/null | jq '[.states[]? | select(. == "off")] | length')
[ "$OFF" -eq 0 ] && { echo "‚úì"; ((PASS++)); } || { echo "‚úó $OFF modules off"; ((FAIL++)); }

echo
echo "[PRE-ACTION] Result: $PASS passed, $FAIL failed"
[ $FAIL -eq 0 ] && echo "‚úì PROCEEDING" || echo "‚úó BLOCKING - fix issues first"
```

---

## Spawn Task (Tu herramienta principal)

### Request Template

```json
{
  "action": "unique_action_name",
  "ttl_seconds": 300,
  "max_retries": 3,
  "mutation": {
    "strategy": "exponential_backoff",
    "base_delay_ms": 1000,
    "multiplier": 2.0,
    "max_delay_ms": 60000
  },
  "target_module": "hormiguero",
  "payload": {}
}
```

### Lifecycle

```
1. POST /spawn
   ‚Üì validate (ttl >= 30, max_retries >= 0)
   ‚Üì INSERT spawns (status='pending')
   ‚Üì POST /spawner/spawn
   ‚Üì daughter created, INSERT daughters
   ‚Üì daughter executes
   ‚Üì if error AND attempt < max_retries: apply mutation, retry
   ‚Üì daughter POST /madre/callback {result}
   ‚Üì madre UPDATE spawns (status='completed')

2. Check:
   SELECT spawn_id, status FROM spawns WHERE spawn_id = ?;
```

### Common Examples

**Scan de incidentes:**
```bash
curl -X POST http://localhost:8008/spawn \
  -H "Content-Type: application/json" \
  -d '{
    "action": "scan_incidents",
    "ttl_seconds": 300,
    "max_retries": 3,
    "target_module": "hormiguero",
    "payload": {"scan_type": "full"}
  }'
```

**Plan de reparaci√≥n:**
```bash
curl -X POST http://localhost:8008/spawn \
  -H "Content-Type: application/json" \
  -d '{
    "action": "generate_repair",
    "ttl_seconds": 600,
    "max_retries": 2,
    "target_module": "manifestator",
    "payload": {"incident_ids": [1, 2, 3]}
  }'
```

**Execute CLI:**
```bash
curl -X POST http://localhost:8008/spawn \
  -H "Content-Type: application/json" \
  -d '{
    "action": "execute_cli",
    "ttl_seconds": 60,
    "max_retries": 1,
    "target_module": "hermes",
    "payload": {"command": "echo hello"}
  }'
```

---

## E2E Flows (Patrones validados)

### Flow A: CLI Execution
```
hermes POST /execute ‚Üí subprocess.run ‚Üí MADRE callback

Verificar:
  sqlite3 data/runtime/vx11.db "SELECT * FROM cli_usage_stats ORDER BY created_at DESC LIMIT 1;"
  sqlite3 data/runtime/vx11.db "SELECT * FROM audit_logs WHERE component LIKE '%cli%' LIMIT 1;"
```

### Flow B: Task Spawn
```
POST /spawn ‚Üí spawns.INSERT ‚Üí daughters.INSERT ‚Üí action ‚Üí callback ‚Üí UPDATE spawns

Verificar:
  sqlite3 data/runtime/vx11.db "SELECT COUNT(*) FROM spawns WHERE action='scan_incidents';"
  sqlite3 data/runtime/vx11.db "SELECT * FROM daughters WHERE spawn_id = '<uuid>';"
```

### Flow C: Auto-Repair
```
hormiguero.scan ‚Üí incidents.INSERT ‚Üí pheromone_log.INSERT ‚Üí manifestator ‚Üí drift_reports.INSERT ‚Üí dsl.apply ‚Üí incidents.UPDATE

Verificar:
  sqlite3 data/runtime/vx11.db "SELECT * FROM drift_reports WHERE status='applied';"
  sqlite3 data/runtime/vx11.db "SELECT * FROM incidents WHERE status='resolved';"
```

---

## Post-Action Mandatory (DESPU√âS de CUALQUIER operaci√≥n)

```bash
#!/bin/bash
TS=$(date -u +%Y%m%dT%H%M%SZ)
mkdir -p docs/audit/$TS

echo "[POST-ACTION] $TS"

# 1. Health recheck
for port in 8000 8001 8002 8003 8004 8006 8007 8008 8011; do
  curl -s http://localhost:$port/health > docs/audit/$TS/health_$port.json 2>/dev/null || echo "{\"error\": \"unreachable\"}" > docs/audit/$TS/health_$port.json
done

# 2. DB checks
sqlite3 data/runtime/vx11.db "PRAGMA quick_check;" > docs/audit/$TS/db_quick_check.txt
sqlite3 data/runtime/vx11.db "PRAGMA integrity_check;" > docs/audit/$TS/db_integrity_check.txt
sqlite3 data/runtime/vx11.db "PRAGMA foreign_key_check;" > docs/audit/$TS/db_fk_check.txt

# 3. MADRE maintenance
curl -X POST http://localhost:8001/madre/power/maintenance/post_task \
  -H "Content-Type: application/json" \
  -d '{}' > docs/audit/$TS/madre_maintenance.json 2>/dev/null

# 4. Regenerate DB artifacts
PYTHONPATH=. python3 -m scripts.generate_db_map_from_db data/runtime/vx11.db 2>/dev/null
python3 scripts/audit_counts.py data/runtime/vx11.db > docs/audit/$TS/counts.json 2>/dev/null

# 5. Snapshot current state
[ -f docs/audit/PERCENTAGES.json ] && cp docs/audit/PERCENTAGES.json docs/audit/$TS/percentages_snapshot.json
[ -f docs/audit/SCORECARD.json ] && cp docs/audit/SCORECARD.json docs/audit/$TS/scorecard_snapshot.json

echo "[POST-ACTION] ‚úì Complete"
echo "Evidence: docs/audit/$TS/"
```

---

## Failure Diagnosis

### Spawn Timeout
```bash
# Check si TTL expir√≥
SPAWN_ID="<uuid>"
sqlite3 data/runtime/vx11.db \
  "SELECT created_at, ttl_seconds, datetime('now') as now, \
          CAST((julianday('now') - julianday(created_at)) * 86400 AS INT) as seconds_elapsed \
   FROM spawns WHERE spawn_id = ?;" "$SPAWN_ID"
```

### Daughter Crash
```bash
# Buscar dump
ls -la forensic/crashes/ | tail -10

# Ver intentos
sqlite3 data/runtime/vx11.db \
  "SELECT attempt_num, strategy FROM daughter_attempts WHERE spawn_id = ? ORDER BY attempt_num;"
```

### DB Foreign Key Violation
```bash
sqlite3 data/runtime/vx11.db -cmd "PRAGMA foreign_keys=ON;" "PRAGMA foreign_key_check;" | head -5
```

### Hermes Token Exhausted
```bash
sqlite3 data/runtime/vx11.db \
  "SELECT provider_id, tokens_used_today, daily_limit_tokens, reset_hour_utc FROM cli_providers;"
```

---

## Agent Capabilities Matrix

| Capacidad | ‚úì/‚úó | Notas |
|-----------|-----|-------|
| Validar health + DB | ‚úì | Pre-action siempre |
| Spawn tasks | ‚úì | Con validation completa |
| CLI execution | ‚úì | Via hermes, respeta tokens |
| Detect incidents | ‚úì | Query a BD |
| Plan repairs | ‚úì | Manifestator analysis |
| Run maintenance | ‚úì | MADRE post_task |
| Regenerate artifacts | ‚úì | Scripts canonicos |
| Modify madre code | ‚úó | Escalate al operador |
| Delete spawns | ‚úó | Escalate al operador |
| Recover BD corrupted | ‚úó | Escalate + manual restore |
| Override rate limits | ‚úó | Espera reset |
| Docker compose direct | ‚úó | Usa override.yml |

---

## System Status at a Glance

```bash
# Todo en un comando
(
  echo "=== VX11 STATUS ==="
  echo "Time: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
  echo "Health: $(for p in 8000 8001; do curl -s http://localhost:$p/health | jq -r '.status' | tr '\n' ' '; done)"
  echo "DB Size: $(du -h data/runtime/vx11.db | cut -f1)"
  echo "Spawns: $(sqlite3 data/runtime/vx11.db 'SELECT COUNT(*) FROM spawns')"
  echo "Incidents: $(sqlite3 data/runtime/vx11.db 'SELECT COUNT(*) FROM incidents')"
  echo "Stability: $(cat docs/audit/PERCENTAGES.json 2>/dev/null | jq -r '.metrics.Estabilidad_operativa_pct.value // "N/A"')%"
  echo "=== END STATUS ==="
)
```

---

---

## Agent Capabilities Matrix v2.1

| Capacidad | ‚úì/‚úó | Prioridad | Notas |
|-----------|-----|----------|-------|
| **AUDITOR√çA** | | | |
| Validar health + DB | ‚úì | P0 | Pre-action siempre |
| Monitoreo real-time | ‚úì | P1 | watch + Redis MONITOR |
| Detecci√≥n anomal√≠as | ‚úì | P1 | TTL spreads, crash loops |
| Analysis tokens | ‚úì | P1 | Hermes usage tracking |
| Performance profiling | ‚úì | P2 | Query slow logs |
| **OPERACIONES** | | | |
| Spawn tasks | ‚úì | P0 | Con validation completa |
| CLI execution | ‚úì | P1 | Via hermes, respeta tokens |
| Detect incidents | ‚úì | P0 | Query a BD |
| Plan repairs | ‚úì | P1 | Manifestator analysis |
| Run maintenance | ‚úì | P0 | MADRE post_task |
| Regenerate artifacts | ‚úì | P1 | Scripts canonicos |
| **LIMPIEZA** | | | |
| Limpiar logs | ‚úì | P2 | SAFE (> 7 d√≠as) |
| Archivar crashes | ‚úì | P2 | SAFE (move a docs/audit) |
| Rotar backups | ‚úì | P2 | SAFE (conserva 2 nuevos) |
| Limpiar audit old | ‚ö†Ô∏è | P3 | AGGRESSIVE (ask) |
| Vaciar tabla BD | ‚ö†Ô∏è | P3 | SURGICAL (ask + confirm) |
| **PROHIBIDO** | | | |
| Modificar madre core | ‚úó | N/A | Escalate al operador |
| Delete spawns/daughters | ‚úó | N/A | Escalate al operador |
| Recover BD corrupted | ‚úó | N/A | Escalate + manual restore |
| Override rate limits | ‚úó | N/A | Espera reset |
| Docker compose direct | ‚úó | N/A | Usa override.yml |
| Tocar tokens/secrets | ‚úó | N/A | READ-ONLY |

---

## Toolkit R√°pido (Copy-Paste Inmediato)

### üü¢ Status Instant (1 l√≠nea)

```bash
echo "Health: $(for p in 8000 8001 8003 8004; do curl -s http://localhost:$p/health 2>/dev/null | jq -r '.status' | head -c1; done), DB: $(du -h data/runtime/vx11.db | cut -f1), Spawns: $(sqlite3 data/runtime/vx11.db 'SELECT COUNT(*) FROM spawns')"
```

### üü¢ Full Audit (copia + pega)

```bash
TS=$(date -u +%Y%m%dT%H%M%SZ); mkdir -p docs/audit/$TS; (
  for port in 8000 8001 8002 8003 8004 8006 8007 8008 8011; do curl -s http://localhost:$port/health > docs/audit/$TS/h$port.json 2>/dev/null; done
  sqlite3 data/runtime/vx11.db "PRAGMA quick_check;" > docs/audit/$TS/db_quick.txt
  curl -X POST http://localhost:8001/madre/power/maintenance/post_task -d '{}' > docs/audit/$TS/madre_post.json 2>&1
  echo "‚úì Auditoria en: docs/audit/$TS/"
)
```

### üü¢ Spawn Quick Task (edit payload)

```bash
curl -X POST http://localhost:8008/spawn \
  -H "Content-Type: application/json" \
  -d '{
    "action": "EDITA_AQUI",
    "ttl_seconds": 300,
    "max_retries": 3,
    "target_module": "hormiguero",
    "payload": {"KEY": "VALUE"}
  }' | jq '.'
```

### üü¢ Monitor Loop (real-time)

```bash
while true; do clear; date; sqlite3 data/runtime/vx11.db "SELECT COUNT(*) as pending FROM spawns WHERE status='pending', COUNT(*) as running FROM spawns WHERE status='running';" | column -t; sleep 2; done
```

### üü° Cleanup Safe (logs + forensic + backups)

```bash
# Logs > 7 d√≠as
find logs -type f -name "*.log" -mtime +7 -delete -print | wc -l

# Archivar crashes
mkdir -p docs/audit/archived_forensic && mv forensic/crashes/* docs/audit/archived_forensic/ 2>/dev/null || true

# Backups: conserva 2
ls -t data/backups/vx11*.db | tail -n +3 | xargs -I {} mv {} data/backups/archived/ && echo "‚úì Rotados"
```

---

## Quick Reference Table

| Necesito... | Comando | Tipo |
|------------|---------|------|
| Status general | `curl -s http://localhost:8000/health` | üü¢ |
| Spawn a task | `curl -X POST http://localhost:8008/spawn -d '...'` | üü¢ |
| Post-task | `curl -X POST http://localhost:8001/madre/power/maintenance/post_task` | üü¢ |
| Ver spawns pending | `sqlite3 data/runtime/vx11.db "SELECT spawn_id, status FROM spawns WHERE status='pending' LIMIT 10;"` | üü¢ |
| Ver incidentes | `sqlite3 data/runtime/vx11.db "SELECT * FROM incidents ORDER BY detected_at DESC LIMIT 5;"` | üü¢ |
| Token usage | `sqlite3 data/runtime/vx11.db "SELECT provider_id, tokens_used_today FROM cli_providers;"` | üü¢ |
| Ver evidencia | `ls -la docs/audit/` | üü¢ |
| DB check | `sqlite3 data/runtime/vx11.db "PRAGMA integrity_check;"` | üü¢ |
| Limpiar logs | `find logs -type f -mtime +7 -delete` | üü° |
| Rotar backups | `ls -t data/backups/vx11*.db \| tail -n +3 \| xargs mv ... archived/` | üü° |

---

## Archivos Esenciales (No Tocar Sin Permiso)

- `data/runtime/vx11.db` ‚Üí BD principal (solo query + backup)
- `docker-compose.yml` ‚Üí Config servicios (usar .override)
- `tokens.env` ‚Üí Secretos (READ-ONLY)
- `madre/main.py` ‚Üí Orchestrator core (code review required)
- `docs/audit/CLEANUP_EXCLUDES_CORE.txt` ‚Üí Validar antes de rm/rmdir

---

## Shortcuts by Use Case

```
MONITOREO
‚îú‚îÄ Status: Status Instant
‚îú‚îÄ Real-time: Monitor Loop
‚îú‚îÄ Anomal√≠as: Detecci√≥n de Anomal√≠as
‚îî‚îÄ Tokens: An√°lisis de Tokens

OPERACI√ìN
‚îú‚îÄ Spawn: Spawn Quick Task
‚îú‚îÄ Post-action: Full Audit
‚îú‚îÄ Health check: Quick Reference
‚îî‚îÄ Maintenance: MADRE post_task

LIMPIEZA (Pedir Confirmaci√≥n)
‚îú‚îÄ Logs: find logs -mtime +7 -delete
‚îú‚îÄ Crashes: Archivar Forensic Crashes
‚îú‚îÄ Backups: Rotar Backups
‚îú‚îÄ Audit old: Limpiar Audit Antiguos
‚îî‚îÄ BD tabla: Vaciar Tabla BD
```

---

**VX11 BOOTSTRAP v2.1 ‚Äî OPERACIONAL**

**√öltima actualizaci√≥n:** 2025-12-24T21:49:31Z  
**Status:** ‚úÖ Todos sistemas UP (9/9), BD OK, autonomy 100%  
**Versi√≥n:** v2.1 (Enhanced Tools + Limpieza Quirurgica)  
**Capabilidad:** Auditor√≠a ‚Üí Operaci√≥n ‚Üí Limpieza (SAFE/AGGRESSIVE/SURGICAL)

**LISTO PARA OPERAR. Todos los atajos, queries, herramientas y recetas de limpieza en un lugar.**


````

