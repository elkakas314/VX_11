/**
 * API Client for VX11 Operator
 * Consumes: tentaculo_link:8000 only (via relative URL)
 * No direct calls to backend services
 * 
 * API base is configurable (VITE_VX11_API_BASE). Defaults:
 * - Dev: http://localhost:8000
 * - Prod: window.location.origin
 */

const TOKEN =
    import.meta.env.VITE_VX11_TOKEN ||
    import.meta.env.VITE_VX11_TENTACULO_TOKEN ||
    'vx11-local-token' // In production: from auth service or config
const RAW_BASE =
    import.meta.env.VITE_VX11_API_BASE ||
    import.meta.env.VITE_VX11_API_BASE_URL ||
    ''
const DEFAULT_BASE = import.meta.env.DEV
    ? 'http://localhost:8000'
    : typeof window !== 'undefined'
      ? window.location.origin
      : 'http://localhost:8000'

export const API_BASE = (RAW_BASE as string).trim() || DEFAULT_BASE

export const buildApiUrl = (path: string) => new URL(path, API_BASE).toString()

interface ApiResponse<T> {
    ok: boolean
    data?: T
    error?: string
    status: number
}

class ApiClient {
    private backoffMs = 1000
    private maxBackoffMs = 30000

    async request<T>(
        method: string,
        path: string,
        body?: any,
        options?: { noRetry?: boolean; timeout?: number }
    ): Promise<ApiResponse<T>> {
        const url = buildApiUrl(path)
        const timeout = options?.timeout || 5000

        try {
            const controller = new AbortController()
            const timeoutId = setTimeout(() => controller.abort(), timeout)

            const response = await fetch(url, {
                method,
                headers: {
                    'Content-Type': 'application/json',
                    'x-vx11-token': TOKEN,
                },
                body: body ? JSON.stringify(body) : undefined,
                signal: controller.signal,
            })

            clearTimeout(timeoutId)

            if (!response.ok) {
                if (
                    response.status === 404 &&
                    !options?.noRetry &&
                    path.startsWith('/operator/api/v1')
                ) {
                    const legacyPath = path.replace('/operator/api/v1', '/operator/api')
                    return this.request(method, legacyPath, body, { ...options, noRetry: true })
                }
                let errorDetail = `HTTP ${response.status}`
                try {
                    const errorJson = await response.json()
                    if (errorJson?.status === 'OFF_BY_POLICY') {
                        errorDetail = errorJson.message || 'OFF_BY_POLICY'
                        return {
                            ok: false,
                            data: errorJson,
                            error: errorDetail,
                            status: response.status,
                        }
                    }
                } catch {
                    // ignore JSON parse errors
                }
                return {
                    ok: false,
                    error: errorDetail,
                    status: response.status,
                }
            }

            const data = await response.json()
            return {
                ok: true,
                data,
                status: response.status,
            }
        } catch (err: any) {
            console.error(`API request failed: ${method} ${path}`, err)
            return {
                ok: false,
                error: err.message || 'Unknown error',
                status: 0,
            }
        }
    }

    // Chat endpoint (P0: via /operator/api/chat)
    async chat(message: string, sessionId?: string): Promise<ApiResponse<any>> {
        return this.request('POST', '/operator/api/v1/chat', {
            message,
            session_id: sessionId,
        })
    }

    // Status endpoint (P0: via /operator/api/status)
    async status(): Promise<ApiResponse<any>> {
        return this.request('GET', '/operator/api/v1/status')
    }

    // Modules endpoint (P0: via /operator/api/modules)
    async modules(): Promise<ApiResponse<any>> {
        return this.request('GET', '/operator/api/v1/modules')
    }

    // Module detail endpoint
    async moduleDetail(name: string): Promise<ApiResponse<any>> {
        return this.request('GET', `/operator/api/v1/modules/${name}`)
    }

    // Events endpoint (P0: via /operator/api/events)
    async events(): Promise<ApiResponse<any>> {
        return this.request('GET', '/operator/api/v1/events')
    }

    // Scorecard endpoint (P0: via /operator/api/scorecard)
    async scorecard(): Promise<ApiResponse<any>> {
        return this.request('GET', '/operator/api/v1/scorecard')
    }

    // Audit endpoint (P0: via /operator/api/audit)
    async audit(): Promise<ApiResponse<any>> {
        return this.request('GET', '/operator/api/v1/audit')
    }

    // Audit detail endpoint
    async auditDetail(id: string): Promise<ApiResponse<any>> {
        return this.request('GET', `/operator/api/v1/audit/${id}`)
    }

    // Download audit endpoint
    async downloadAudit(id: string): Promise<ApiResponse<any>> {
        return this.request('GET', `/operator/api/v1/audit/${id}/download`)
    }

    // Settings endpoint (P0: via /operator/api/settings)
    async settings(): Promise<ApiResponse<any>> {
        return this.request('GET', '/operator/api/v1/settings')
    }

    // Update settings endpoint
    async updateSettings(settings: any): Promise<ApiResponse<any>> {
        return this.request('POST', '/operator/api/v1/settings', settings)
    }

    // Topology endpoint (P0: via /operator/api/topology)
    async topology(): Promise<ApiResponse<any>> {
        return this.request('GET', '/operator/api/v1/topology')
    }

    // Power state endpoint (legacy, still available)
    async windows(): Promise<ApiResponse<any>> {
        return this.request('GET', '/operator/api/v1/windows')
    }

    // Hormiguero status (optional, may be unavailable)
    async hormigueroStatus(): Promise<ApiResponse<any>> {
        return this.request('GET', '/operator/api/v1/hormiguero/status', undefined, { timeout: 3000 })
    }

    // Hormiguero incidents (optional, for debug mode)
    async hormigueroIncidents(): Promise<ApiResponse<any>> {
        return this.request('GET', '/hormiguero/incidents?limit=10', undefined, { timeout: 3000 })
    }

    // P0 UI checks - verify all endpoints are reachable
    async runP0Checks(): Promise<{
        chat_ask: boolean
        status: boolean
        windows: boolean
        hormiguero_status: boolean
        results: Record<string, any>
    }> {
        const results: Record<string, any> = {}

        const chatResp = await this.chat('ping')
