async def health():
    return {
        "status": "ok",
        "module": "switch",
        "active_model": models.active,
        "warm_model": models.warm,
        "queue_size": len(queue.snapshot()),
    }


@app.get("/switch/context")
async def switch_context_get():
    """Return current context: mode, active models, queue stats, token_required."""
    return {
        "status": "ok",
        "mode": CURRENT_MODE,
        "active_model": models.active,
        "warm_model": models.warm,
        "queue_size": len(queue.snapshot()),
        "token_required": settings.enable_auth,
    }


@app.post("/switch/advice")
async def switch_advice(req: AdviceRequest):
    """Minimal advice endpoint for incident summaries (backwards compatible)."""
    summary = req.incident_summary or {}
    severity = summary.get("severity") or summary.get("status") or "unknown"
    recommendations = []
    if severity in ("critical", "high"):
        recommendations.append("escalate_to_madre")
    elif severity in ("warning", "info"):
        recommendations.append("observe")
    return {
        "recommendations": recommendations,
        "scoring": {"score": 0, "severity": severity},
    }


@app.get("/switch/providers")
async def switch_providers_list():
    """Return list of providers: CLI + local + remote with key fields."""
    session = get_session("vx11")
    try:
        cli_rows = session.query(CLIRegistry).filter_by(available=True).all()
        cli_list = [
            {
                "name": r.name,
                "kind": "cli",
                "status": "available" if r.available else "unavailable",
                "rate_limit_daily": r.rate_limit_daily or 0,
            }
            for r in cli_rows
        ]
    except Exception:
        cli_list = []
    finally:
        session.close()

    local_list = [
        {"name": m.name, "kind": "local", "status": m.status}
        for m in models.available.values()
    ]

    return {"status": "ok", "providers": cli_list + local_list}


@app.get("/switch/fluzo")
async def switch_fluzo_profile():
    """Return FLUZO profile and signals via FLUZOClient."""
    try:
        client = FLUZOClient()
        profile = client.get_profile()
        return {"status": "ok", "profile": profile}
    except Exception as e:
        write_log("switch", f"fluzo_profile_error:{e}", level="ERROR")
        raise HTTPException(status_code=500, detail="fluzo_error")


@app.get("/switch/fluzo/signals")
async def switch_fluzo_signals():
    """Return raw FLUZO signals."""
    try:
        client = FLUZOClient()
        signals = client.get_signals()
        return {"status": "ok", "signals": signals}
    except Exception as e:
        write_log("switch", f"fluzo_signals_error:{e}", level="ERROR")
        raise HTTPException(status_code=500, detail="fluzo_error")


@app.get("/metrics{suffix:path}")
async def metrics_stub(suffix: str = ""):
    """Lightweight stub to silence missing metrics probes."""
    name = (suffix or "/metrics").lstrip("/")
    if not name:
        name = "metrics"
    # Return a small, consistent payload expected by tests
    unit_map = {
        "cpu": "percent",
        "memory": "percent",
