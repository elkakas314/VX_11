"""
VX11 Operator Routes: Audit Runs
tentaculo_link/routes/audit.py

Endpoints: GET /api/audit/runs, GET /api/audit/{id}, GET /api/audit/{id}/download
"""

from typing import Optional, List, Dict, Any
from fastapi import APIRouter, Depends, Header, HTTPException
from fastapi.responses import StreamingResponse
import os
import json
import sqlite3
from pathlib import Path
import zipfile
import io
import re
from datetime import datetime

router = APIRouter(prefix="/api", tags=["audit"])


def check_auth(x_vx11_token: Optional[str] = Header(None)) -> bool:
    if not os.environ.get("ENABLE_AUTH", "true").lower() in ("true", "1"):
        return True
    required_token = os.environ.get("VX11_TENTACULO_LINK_TOKEN", "")
    if not x_vx11_token:
        raise HTTPException(status_code=401, detail="auth_required")
    if x_vx11_token != required_token:
        raise HTTPException(status_code=403, detail="forbidden")
    return True


def get_db() -> sqlite3.Connection:
    repo_root = Path(os.environ.get("VX11_REPO_ROOT", "/home/elkakas314/vx11"))
    db_path = repo_root / "data" / "runtime" / "vx11.db"
    conn = sqlite3.connect(str(db_path), timeout=5.0)
    conn.row_factory = sqlite3.Row
    return conn


def get_audit_root() -> Path:
    repo_root = Path(os.environ.get("VX11_REPO_ROOT", "/home/elkakas314/vx11"))
    return repo_root / "docs" / "audit"


def parse_run_timestamp(name: str) -> Optional[str]:
    match = re.match(r"^(\\d{8}T\\d{6}Z)", name)
    if not match:
        return None
    try:
        dt = datetime.strptime(match.group(1), "%Y%m%dT%H%M%SZ")
        return dt.isoformat() + "Z"
    except ValueError:
        return None


def list_audit_runs(limit: int, offset: int) -> Dict[str, Any]:
    audit_root = get_audit_root()
    if not audit_root.exists():
        return {"runs": [], "total": 0, "has_more": False}

    candidates = [
        path
        for path in audit_root.iterdir()
        if path.is_dir() and not path.name.startswith(".")
    ]
    candidates.sort(key=lambda p: p.name, reverse=True)

    total = len(candidates)
    selected = candidates[offset : offset + limit]

    runs = []
    for path in selected:
        run_ts = parse_run_timestamp(path.name)
        files = [file_path for file_path in path.rglob("*") if file_path.is_file()]
        size_bytes = sum(file_path.stat().st_size for file_path in files)
        runs.append(
            {
                "run_id": path.name,
                "run_ts": run_ts,
                "status": "available",
                "path": str(path),
                "files_count": len(files),
                "size_bytes": size_bytes,
            }
        )

    return {
        "runs": runs,
        "total": total,
        "has_more": (offset + limit) < total,
    }


@router.get("/audit/runs")
async def get_audit_runs(
    limit: int = 20,
    offset: int = 0,
    status: Optional[str] = None,
    auth: bool = Depends(check_auth),
):
    """
    GET /api/audit/runs - List audit runs

    Query Parameters:
    - limit: Max results (default 20)
    - offset: Pagination offset
    - status: Filter by status (draft|approved|applied|rolled_back)

    Response:
    {
      "runs": [
        {
          "audit_id": "string",
          "run_ts": "2025-12-29T...",
          "status": "draft|approved|applied|rolled_back",
          "correlation_id": "string|null",
          "summary": "Brief description",
          "p0_count": 0
        }
      ],
      "total": 42,
      "has_more": true
    }
    """

    if os.environ.get("VX11_AUDIT_ENABLED", "false").lower() in ("true", "1"):
        try:
            conn = get_db()
            cursor = conn.cursor()

            where_clause = ""
            params = []
            if status:
                where_clause = "WHERE status = ?"
                params = [status]

            cursor.execute(
                f"SELECT COUNT(*) as cnt FROM manifestator_audit {where_clause}", params
            )
            total = cursor.fetchone()["cnt"]

            cursor.execute(
                f"""
                SELECT audit_id, run_ts, status, correlation_id,
                       COALESCE(patch_plan_json, '{{}}') as patch_plan, evidence_paths_json
                FROM manifestator_audit
                {where_clause}
                ORDER BY run_ts DESC
                LIMIT ? OFFSET ?
                """,
                params + [limit, offset],
            )
            rows = cursor.fetchall()
            conn.close()

            runs = []
            for row in rows:
                try:
                    patch = json.loads(row["patch_plan"] or "{}")
                    summary = patch.get("summary", "Audit run")
                except json.JSONDecodeError:
                    summary = "Audit run"

                runs.append(
                    {
                        "run_id": row["audit_id"],
                        "run_ts": row["run_ts"],
                        "status": row["status"],
                        "correlation_id": row["correlation_id"],
                        "summary": summary,
                        "source": "manifestator_audit",
                    }
                )

            return {
                "runs": runs,
                "total": total,
                "has_more": (offset + limit) < total,
            }
        except Exception:
            pass

    return list_audit_runs(limit=limit, offset=offset)


@router.get("/audit/{audit_id}")
async def get_audit_detail(
    audit_id: str,
    auth: bool = Depends(check_auth),
):
    """
    GET /api/audit/{audit_id} - Get audit run details

    Response:
    {
      "audit_id": "string",
      "run_ts": "2025-12-29T...",
      "status": "string",
      "findings": [
        {
          "severity": "P0|P1|P2",
          "title": "string",
          "detail": "string",
          "evidence_paths": ["string"]
        }
      ],
      "artifacts": ["path/to/file1", "path/to/file2"]
    }
    """

    audit_root = get_audit_root()
    audit_path = audit_root / audit_id
    if audit_path.exists() and audit_path.is_dir():
        files: List[Dict[str, Any]] = []
        for path in sorted(audit_path.rglob("*")):
            if path.is_file():
                files.append(
                    {
                        "path": str(path.relative_to(audit_root)),
                        "size_bytes": path.stat().st_size,
                    }
                )
        return {
            "run_id": audit_id,
            "run_ts": parse_run_timestamp(audit_id),
            "status": "available",
            "files": files,
        }

    if os.environ.get("VX11_AUDIT_ENABLED", "false").lower() in ("true", "1"):
        try:
            conn = get_db()
            cursor = conn.cursor()
            cursor.execute(
                """
                SELECT audit_id, run_ts, status, patch_plan_json, evidence_paths_json
                FROM manifestator_audit
                WHERE audit_id = ?
