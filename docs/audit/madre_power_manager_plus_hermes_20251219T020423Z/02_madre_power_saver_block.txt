    if os.environ.get("VX11_DB_PATH"):
        return os.environ["VX11_DB_PATH"]

    candidates = ["./data/runtime/vx11.db", "/app/data/runtime/vx11.db"]
    for c in candidates:
        if os.path.exists(c):
            return c

    try:
        from config.database import DATABASE_URL  # type: ignore

        if isinstance(DATABASE_URL, str) and DATABASE_URL.startswith("sqlite:"):
            raw = DATABASE_URL[len("sqlite:") :]
            while raw.startswith("/"):
                raw = raw[1:]
            return raw
    except Exception:
        pass

    return "./data/runtime/vx11.db"


def db_retention_cleanup(
    out_dir: str,
    apply: bool = False,
    db_path: str = None,
) -> Dict[str, Any]:
    """
    Plan (apply=False) or execute (apply=True) DB retention cleanup on the unified vx11 SQLite DB.

    Writes evidence files into out_dir:
    - db_retention_plan.json
    - db_retention_result.json (only when apply=True)
    """
    db_path = _resolve_db_path(db_path)

    def _env_int(name: str, default: int) -> int:
        raw = os.environ.get(name)
        if raw is None:
            return default
        try:
            return int(raw)
        except Exception:
            return default

    def _profile() -> str:
        val = (
            os.environ.get("VX11_RETENTION_PROFILE")
            or os.environ.get("VX11_POWER_PROFILE")
            or os.environ.get("VX11_POWER_MODE")
        )
        if val:
            return val.strip().lower()
        if os.environ.get("ULTRA_LOW_MEMORY", "").strip().lower() in ("1", "true", "yes", "on"):
            return "low_power"
        return "default"

    profile = _profile()
    default_log_days = _env_int("VX11_RETENTION_LOG_DAYS", 30)
    low_power_log_days = _env_int("VX11_RETENTION_LOG_DAYS_LOW_POWER", 7)

    def _days_for(table: str, default: int, kind: str = "log") -> int:
        env_name = f"VX11_RETENTION_{table.upper()}_DAYS"
        if env_name in os.environ:
            return _env_int(env_name, default)
        if kind == "log" and profile in ("low_power", "ultra_low_memory"):
            return low_power_log_days
        if kind == "log":
            return default_log_days
        return default

    rules = [
        {"table": "incidents", "ts_col": "detected_at", "days": _days_for("incidents", 90, kind="state")},
        {"table": "pheromone_log", "ts_col": "created_at", "days": _days_for("pheromone_log", 14, kind="log")},
        {"table": "routing_events", "ts_col": "timestamp", "days": _days_for("routing_events", 30, kind="log")},
        {"table": "cli_usage_stats", "ts_col": "timestamp", "days": _days_for("cli_usage_stats", 30, kind="log")},
        {"table": "system_events", "ts_col": "timestamp", "days": _days_for("system_events", 30, kind="log")},
        {"table": "scheduler_history", "ts_col": "timestamp", "days": _days_for("scheduler_history", 30, kind="log")},
        {"table": "intents_log", "ts_col": "created_at", "days": _days_for("intents_log", 30, kind="log")},
        {"table": "ia_decisions", "ts_col": "created_at", "days": _days_for("ia_decisions", 30, kind="log")},
        {
            "table": "model_usage_stats",
            "ts_col": "created_at",
            "days": _days_for("model_usage_stats", 90, kind="state"),
        },
    ]

    plan: Dict[str, Any] = {
        "timestamp_utc": datetime.datetime.utcnow().isoformat() + "Z",
        "db_path": db_path,
        "apply": apply,
        "profile": profile,
        "defaults": {
            "log_days_default": default_log_days,
            "log_days_low_power": low_power_log_days,
        },
        "rules": rules,
        "actions": [],
        "errors": [],
    }

