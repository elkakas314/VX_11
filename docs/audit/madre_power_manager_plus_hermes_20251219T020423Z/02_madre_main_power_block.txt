        raise HTTPException(status_code=403, detail="Invalid token")

    # Resume plan
    MadreDB.update_task(plan_id, status="running")
    MadreDB.record_action(
        module="madre",
        action="plan_confirmed",
        reason=f"plan_id:{plan_id}",
    )

    return {"status": "confirmed", "plan_id": plan_id}


# ====== POWER SAVER ENDPOINTS ======
from pydantic import BaseModel


class IdleMinRequest(BaseModel):
    apply: bool = False


class RitualRequest(BaseModel):
    apply: bool = False


@app.get("/power/status")
async def power_status():
    out_dir = power_saver_module.make_out_dir(prefix="madre_power_saver_status")
    # snapshot and zombies
    await asyncio.to_thread(power_saver_module.snapshot, out_dir)
    z = await asyncio.to_thread(power_saver_module.list_zombies)
    # processes in repo
    proc_list = []
    try:
        p = subprocess = __import__("subprocess")
        res = p.run(
            "ps axo pid,ppid,stat,cmd | grep /home/elkakas314/vx11 || true",
            shell=True,
            capture_output=True,
            text=True,
        )
        proc_list = [l for l in res.stdout.splitlines() if l.strip()]
    except Exception:
        proc_list = []
    # build response
    return {
        "timestamp": datetime.utcnow().isoformat(),
        "out_dir": out_dir,
        "zombies_count": len(z),
        "repo_processes": proc_list,
    }


@app.post("/power/idle_min")
async def power_idle_min(req: IdleMinRequest):
    out_dir = power_saver_module.make_out_dir(prefix="madre_power_saver_idle_min")
    # run plan; idle_min is safe by default (apply default False)
    res = await asyncio.to_thread(power_saver_module.idle_min, out_dir, req.apply)
    report = await asyncio.to_thread(power_saver_module.final_report, out_dir)
    return {
        "status": "ok",
        "out_dir": out_dir,
        "applied": req.apply,
        "report": report,
        "result": res,
    }


@app.post("/power/regen_dbmap")
async def power_regen_dbmap():
    out_dir = power_saver_module.make_out_dir(prefix="madre_power_saver_regen")
    res = await asyncio.to_thread(power_saver_module.regen_dbmap, out_dir)
    report = await asyncio.to_thread(power_saver_module.final_report, out_dir)
    return {"status": "ok", "out_dir": out_dir, "result": res, "report": report}


@app.post("/power/ritual")
async def power_ritual(req: RitualRequest):
    out_dir = power_saver_module.make_out_dir(prefix="madre_power_saver_ritual")
    # snapshot
    await asyncio.to_thread(power_saver_module.snapshot, out_dir)
    # zombies write
    await asyncio.to_thread(power_saver_module.write_zombies, out_dir)
    # idle_min (plan or apply)
    idle_res = await asyncio.to_thread(power_saver_module.idle_min, out_dir, req.apply)
    # postcheck snapshot
    await asyncio.to_thread(power_saver_module.snapshot, out_dir)
    # regen dbmap
    regen_res = await asyncio.to_thread(power_saver_module.regen_dbmap, out_dir)
    # final report
    report = await asyncio.to_thread(power_saver_module.final_report, out_dir)
    return {
        "status": "ok",
        "out_dir": out_dir,
        "applied": req.apply,
        "idle_res": idle_res,
        "regen_res": regen_res,
        "report": report,
    }


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(app, host="0.0.0.0", port=8001)

# ===== BACKCOMPAT EXPORTS (tests + legacy clients) =====
# Exportamos compatibilidad m√≠nima para tests que importan desde madre.main
from typing import Optional, Dict, Any
from pydantic import BaseModel
import os

try:
    # If legacy app exists, prefer its routes for full compatibility in tests
    # Mark import-safe for tests to avoid legacy module running background tasks or seeding DB
    os.environ.setdefault("VX11_TEST_IMPORT_SAFE", "1")
    from madre.main_legacy import app as _legacy_app  # type: ignore

    app = _legacy_app
except Exception:
    pass
